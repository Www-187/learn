## 1.this关键字

#### 概念

- this代指当前对象，当前正在创建的对象，当前正在初始化的对象

- this在类的内部使用，可以调用成员变量，方法和构造器
  - 在方法中使用，表示调用该方法的对象
  - 在构造器中使用，表示该构造器正在初始化的对象

#### 格式

- ```java
  this.属性名;//表示当前正在创建的对象的属性
  this();//表示调用类的空参构造器
  this(String name,int age);//表示调用类的有参构造器
  ```

- ```java
  class User{
      String name;
      int age;
      
      //空参构造器
      public User(){
          
      }
      
      //有参构造器
      public User(String name){
          this();//调用空参构造器
          
          /*这里使用this关键字调用属性，指的是当前正在创建的对象的属性，即当前正在创建的对象的属性等于创建对象时给的值*/
          this.name=name;
      }
      
      //有参构造器
      public User(int age){
          this(String name);//调用有参构造器
          this.age=age;//同上
      }
  }
  ```

#### 使用地方

- 在创建类的方法时，方法的形参名可能会和类属性同名，在方法体内使用this，this.属性就指的是正在创建的对象的属性

  - ```java
    public void set(String name,int age){
        /*正在创建的对象的属性等于形参*/
        this.name=name;
        this.age=age;
    }
    ```

#### 注意

- this访问的属性或方法如果在本类中没找到，会从父类查找
- 注意this调用构造器时不能出现递归调用，否则就形成了一个环
  - 即得出，如果一个类声明了n个构造器，则最多有n-1个构造器使用了this(形参列表)
- this()和this(形参列表)只能出现在构造器的首行
  - 即得出，在构造器中，最多声明一个this(形参列表)

------

## 2.继承性

#### 角度

- 从上向下的继承
  - 例如：人类到学生类
- 从下向上的继承
  - 例如：狗类到动物类

#### 格式

- 关键字：extends，扩展

- ```java
  class A{}
  class B extends A{}//类B继承了类A
  ```

#### 概念

- 叫法

  - 父类，又叫超类，SuperClass

  - 子类，又叫派生类，SubClass

- 子类继承了父类的所有属性和方法，但不继承构造器
  - 创建对象时，在堆中申请内存时，就要看父类和子类都声明了什么变量，这些变量都要分配内存
  - 对象调用方法时，编译器会在子类模板看是否有这个方法，没找到，就向上（父类，父类的父类）找
  - 继承意味着子类对象要看子类模板和父类模板
- 子类不能访问父类的私有变量和方法（封装性的体现），注意
- java支持多层继承（Object-->Person-->Student），而不支持多重继承
- 所有类默认继承Object类

#### 好处

- 继承的出现减少了代码的冗余，提高了代码的复用性
- 有利于功能的扩展
- 继承的出现让类与类之间产生了is-a的关系，为多态的使用提供了前提
  - 猫is-a动物，学生is-a人

------

## 3.方法的重写

#### 概念

- 在继承之后，子类可以对从父类继承来的方法进行重写，也叫重置，覆盖父类方法。（注意私有方法不行）

#### 格式

- ```java
  //父类的返回面积的方法
  public double findArea(){
      return 0.0;
  }
  //子类重写的方法
  @overwrite
  public vodi findArea(){
      return PI*radius*radius;
  }
  ```

#### 注意

- 属性没有重写一说

- 建议直接赋值父类的方法头过来，或直接IDEA生成重写方法
- 重写方法要与被重写方法保持相同的方法名，形参列表
- 重写的方法的返回类型要小于等于被重写的方法（包括引用尅性Student<Person），void除外
- 重写方法的访问权限要大于等于父类被重写的方法
- 重写方法的异常要小于等于被重写的方法的异常
- 此外，子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。

------

## 4.super关键字

#### 概念

- 使用super来调用父类中的属性，方法，构造器
- super的追溯是一直向上的，不局限于直接父类

#### 格式

- ```java
  super.属性名;//父类的属性
  super.方法名;//父类的方法
  super(形参列表);//父类构造器
  ```

#### 注意

- 如果子类重写了父类的方法，使用super.方法名，才能调用父类的被重写方法，否则调用的是子类重写过的方法
  - 方法前没this和super，先从本类中匹配，没有就往上找
  - 方法前有this，从子类找，没有就向上
  - 方法前有super，直接在父类找，没有就向上
- 编译器在找变量时，注意就近原则
- 在子类构造器中，this(形参)和super(形参)二选一（因为必须在首行），如果都没有显示声明，就默认是super()；即父类空参构造器。因此子类构造器没有显示写this和super，而且父类也没有空参构造器，就编译错误
- 子类中任何一个构造器，要么调用本类中重载的构造器，要么调用父类的构造器
- 一个类声明了n个构造器，最多有n-1个构造器使用了this(形参列表)，剩下的一个一定使用了super(形参列表)

#### 子类对象实例化时

- 子类创建对象时，一定会调用父类构造器，且调用父类构造器的代码在首行，因此是先加载父类，在加载子类

------

## 5.多态性

#### 概念

- 我需要一个玩具，你给我一辆小汽车，一个玩偶都行。在参数列表中，我需要的是父类的对象（Object），你可以传递过来子类的对象（String，Person）
- 多态性：子类对象的多态性。在Java中，子类的对象可以替代父类的对象使用。所以，一个引用类型变量可能指向多种不同类型的对象
- 多用于传递参数

#### 格式

- 父类名 对象名 = new 子类名();父类的引用指向子类的对象

- ```java
  //Person类
  class Person{
      method1(){
          //方法1
      }
      method2(){
          //方法2
      }
  }
  //Man类，继承Person类
  class Man extends Person{
      method1(){
          //重写父类的method1()
      }
      
  }
  //Woman类，继承Person类
  class Woman extends Perosn{
      method1(){
          //重写父类的method1()
      }
  } 
  //main方法
  main(){
      //父类名 对象名 = new 子类名();
      Perosn p1 = new Man();//Perosn类型的变量p1，指向Man类型的对象
      p1=new Woman();//指向多种不同类型的对象
      p1.method1();//调用的是子类的方法，子类中重写了
      p1.method2();//调用的是父类的方法，子类中没重写
  }
  ```

#### 理解

- Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简称：编译时，看左边；运行时，看右边
- 对象的编译时类型和运行时类型不一致，就是多态性
- 在多态下，调用方法：在编译时，认为是父类类型，即父类中的方法。在运行时，实际执行的子类中被重写的方法（如果这个方法在子类中被重写了），没被重写就执行父类中的方法。（编译时，看左边；运行时，看右边）
- 多态的使用：虚方法调用：在Java中虚方法是指在编译阶段不能确定方法的调用入口地址，在运行阶段才能确定的方法，即可能被重写的方法
- 在多态下，对象的属性和方法都看的是父类，子类自己独有的属性和方法不能用。
- 多态的前提：类的继承关系，方法的重写

#### 多态的优缺点

- 优点

  - 减少了大量的重载的方法的定义

  - 变量引用的子类对象不同，执行的方法就不同，实现动态绑定。代码编写更灵活，可维护性和扩展性更好

- 缺点

  - 在多态下不能使用子类特有的属性（属性是在编译时确定的）和方法

------

## 6.向上与向下转型

#### 了解

- 因为多态，就一定会有把子类对象赋值给父类变量的时候，这个时候，在`编译期间`，就会出现类型转换的现象。但是，使用父类变量接收了子类对象之后，我们就`不能调用`子类拥有，而父类没有的方法了。这也是多态给我们带来的一点"小麻烦"。所以，想要调用子类特有的方法，必须做类型转换，使得`编译通过`。

#### 向上转型

- 创建对象时，当左边类型>右边类型，就是向上转型，即多态

#### 向上转型

- 当左边类型<右边类型，就是向下转型，即多态的逆过程

#### instanceof关键字

- 格式：对象a instanceof 类A名

- 返回布尔类型

- 检验对象a是否是数据类型A的对象

- 如果对象a属于类A的子类B，a instanceof A值也为true

- 综合以上2点：判断对象a是否是类A或其子类的对象实例

- ```java
  Person p1 = new Man();//多态
  p1.getClass();//输出的是Man，即p1是Man类的对象
  p1 instanceof Man;//true，p1是Man类的实例
  p1 instanceof Person;//true，p1是Man类的对象，Man类是Person的子类
  p1 instanceof Woman;//fasle，p1不是Woman类实例
  ```

- 当要进行向下转型时，先使用instanceof关键字进行判断，否则容易报类型转换异常，ClassCastException

#### 向上转型格式

- 使用强转符：()

- ```java
  Man m1=(Man)p1;//新建子类的对象来接收被强转的原来的对象
  ```

------

## 7.Objeact类

#### 概念

- Object类，是根父类，每个类都使用其作为父类
- 如果一个类没有特别指定父类，那么默认则继承自Object类
- 所有对象（包括数组）都实现这个类的方法

#### object类的方法

- 重点：

- 比较：boolean equals(Object obj)

  - ```java
    p1.equals(p2);//比较地址是否相同
    ```

  - 只能使用于引用数据类型，不能使用于基本数据类型，没重写之前，与“==”的作用相同，比较两个引用数据类型的地址是否相同
  - 在File，String，Date类和包装类中都重写了该方法，因此比较的是内容是否相等
  - 可直接生成此方法

- 输出： String toString()

  - 默认情况下，toString()返回的是“对象的运行时类型 @ 对象的hashCode值的十六进制形式"

  - 如果我们直接System.out.println(对象)，默认会自动调用这个对象的toString()

  - 在进行String与其它类型数据的连接操作时，自动调用toString()方法

    ```java
    Date now=new Date();
    System.out.println(“now=”+now);  //相当于
    System.out.println(“now=”+now.toString()); 
    ```

  - 可直接生成此方法

- 了解：

  - getClass()：获取对象的运行时所属的类
  - hashCode()：返回每个对象的hash值
  - clone()：克隆（新建）一个对象，属性一样，地址值不一样
  - finalize()：当对象被回收时，系统自动调用该对象的 finalize() 方法。（不是垃圾回收器调用的，是本类对象调用的）永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。什么时候被回收：当某个对象没有任何引用时，JVM就认为这个对象是垃圾对象，就会在之后不确定的时间使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用 finalize()方法。 子类可以重写该方法，目的是在对象被清理之前执行必要的清理操作。比如，在方法内断开相关连接资源。如果重写该方法，让一个新的引用变量重新引用该对象，则会重新激活对象。在JDK 9中此方法已经被`标记为过时`的。

------





































